{"version":3,"sources":["../../src/dataStructures/queue.ts"],"sourcesContent":["/**\n * A generic Queue class that can store elements of any type.\n */\nexport class Queue<T> {\n  private count: number;\n  private lowestCount: number;\n  private items: { [key: number]: T };\n\n  /**\n    * Constructs a new Queue instance.\n    */\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n\n  /**\n    * Enqueues an element to the end of the queue.\n    * @param element - The element to enqueue.\n    */\n  enqueue(element: T): void {\n    this.items[this.count] = element;\n    this.count += 1;\n  }\n\n  /**\n    * Adds an element to the queue. This is an alias for enqueue.\n    * @param element - The element to add to the queue.\n    */\n  add(element: T): void {\n    this.enqueue(element);\n  }\n\n  /**\n    * Dequeues an element from the front of the queue.\n    * @returns The dequeued element, or undefined if the queue is empty.\n    */\n  dequeue(): T | undefined {\n    if (this.isEmpty()) return undefined;\n    const result = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount += 1;\n    return result;\n  }\n\n  /**\n    * Removes an element from the queue. This is an alias for dequeue.\n    * @returns The removed element, or undefined if the queue is empty.\n    */\n  remove(): T | undefined {\n    return this.dequeue();\n  }\n\n  /**\n    * Peeks at the front element of the queue without removing it.\n    * @returns The front element, or undefined if the queue is empty.\n    */\n  peek(): T | undefined {\n    if (this.isEmpty()) return undefined;\n    return this.items[this.lowestCount];\n  }\n\n  /**\n    * Scry at the front element of the queue without removing it. This is an alias for peek.\n    * @returns The front element, or undefined if the queue is empty.\n    */\n  scry(): T | undefined {\n    return this.peek();\n  }\n\n  /**\n    * Checks if the queue is empty.\n    * @returns True if the queue is empty, false otherwise.\n    */\n  isEmpty(): boolean {\n    return this.count - this.lowestCount === 0;\n  }\n\n  /**\n    * Gets the size of the queue.\n    * @returns The size of the queue.\n    */\n  size(): number {\n    return this.count - this.lowestCount;\n  }\n\n  /**\n    * Gets the length of the queue. This is an alias for size.\n    * @returns The length of the queue.\n    */\n  length(): number {\n    return this.size();\n  }\n\n  /**\n    * Clears the queue.\n    */\n  clear(): void {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n\n  /**\n    * Converts the queue to an array.\n    * @returns An array representation of the queue.\n    */\n  toArray(): T[] {\n    return Object.values(this.items)\n  }\n\n  /**\n    * Converts the queue to a string.\n    * @returns A string representation of the queue.\n    */\n  toString(): string {\n    if (this.isEmpty()) return '';\n    const values = Object.values(this.items).slice(this.lowestCount, this.count);\n    return values.join(', ');\n  }\n\n  /**\n   * Asynchronously generates a string representation of the queue, good for large queues.\n   * @returns An asynchronous generator that yields chunks of the string representation.\n   */\n  async *asyncToStringGenerator() {\n    if (this.isEmpty()) return;\n    const values = Object.values(this.items);\n    let currentIndex = this.lowestCount;\n    const chunkSize = 100; // Adjust based on your needs\n\n    while (currentIndex < this.count) {\n      const chunk = values.slice(currentIndex, currentIndex + chunkSize).join(', ');\n      yield chunk;\n      currentIndex += chunkSize;\n    }\n  }\n\n  /**\n   * Converts the queue to a string asynchronously.\n   * \n   * @returns A promise that resolves to the string representation of the queue.\n   */\n  async toStringAsync(): Promise<string> {\n    let result = '';\n    for await (const chunk of this.asyncToStringGenerator()) {\n      result += chunk;\n    }\n    return result;\n  }\n\n  /**\n   * Iterates over the elements in the queue.\n   * @param callback - The callback function to execute for each element.\n   */\n  forEach(callback: (iteratorValue: T, tempIterator: number, queueItem: Record<string, T>) => any): void {\n    if (this == null) throw new TypeError('\"this\" is null or not defined');\n    if (typeof callback !== 'function') throw new TypeError(`${callback} is not a function`);\n\n    const queueObject = Object(this); // Assign the results of 'this' to queueObject\n    const keys = Object.keys(queueObject.items); // Get an array of keys\n    const queueLength: number = keys.length; // Get the queue's length\n    let scopeArg;\n    if (arguments.length > 1) scopeArg = arguments[1];\n\n    for (let tempIterator = 0; tempIterator < queueLength; tempIterator++) {\n      const key = keys[tempIterator];\n      const iteratorValue = queueObject.items[key];\n      callback.call(scopeArg, iteratorValue, Number(key), queueObject.items);\n    }\n  }\n\n  /**\n   * Asynchronously iterates over each item in the queue and executes the provided callback function.\n   * @param callback - The callback function to be executed for each item in the queue.\n   * @returns A promise that resolves when all iterations are complete.\n   */\n  async *asyncForEachGenerator(callback: (iteratorValue: T, tempIterator: number, queueItem: Record<string, T>) => Promise<any>) {\n    if (this == null) throw new TypeError('\"this\" is null or not defined');\n    if (typeof callback !== 'function') throw new TypeError(`${callback} is not a function`);\n\n    const queueObject = Object(this); // Assign the results of 'this' to queueObject\n    const keys = Object.keys(queueObject.items); // Get an array of keys\n    const queueLength: number = keys.length; // Get the queue's length\n\n    for (let tempIterator = 0; tempIterator < queueLength; tempIterator++) {\n      const key = keys[tempIterator];\n      const iteratorValue = queueObject.items[key];\n      yield callback.call(undefined, iteratorValue, Number(key), queueObject.items);\n    }\n  }\n\n  async asyncForEach(callback: (iteratorValue: unknown, tempIterator: number, queueItem: unknown) => Promise<any>): Promise<void> {\n    for await (const _ of this.asyncForEachGenerator(callback)) {\n      // The generator yields each item, so we don't need to do anything here\n      // The purpose of this function is to allow for async callback execution\n    }\n  }\n\n  /**\n    * Iterates over the elements in the queue in reverse order.\n    * @param callback - The callback function to execute for each element.\n    */\n  forEachReverse(callback: (element: T, index: number) => void): void {\n    if (this.isEmpty()) return;\n    const keys = Object.keys(this.items).reverse() as Array<keyof T>;\n    for (const key of keys) {\n      const index = Number(key) - this.lowestCount;\n      callback(this.items[Number(key)], index);\n    }\n  }\n\n\n  /**\n    * Maps the elements in the queue to a new array.\n    * @param callback - The callback function to execute for each element.\n    * @returns A new array with the results of calling the callback function for each element.\n    */\n  map(callback: (element: T, index: number) => T): T[] {\n    return this.toArray().map((element, index) => callback(element, index));\n  }\n\n\n  /**\n    * Filters the elements in the queue based on a condition.\n    * @param callback - The callback function to execute for each element.\n    * @returns A new array with the elements that pass the test implemented by the provided function.\n    */\n  filter(callback: (element: T, index: number) => boolean): T[] {\n    return this.toArray().filter((element, index) => callback(element, index));\n  }\n\n\n  /**\n    * Reduces the elements in the queue to a single value.\n    * @param callback - The callback function to execute for each element.\n    * @param initialValue - The initial value for the accumulator.\n    * @returns The accumulated value.\n    */\n  reduce(callback: (accumulator: T, element: T, index: number) => T, initialValue: T): T {\n    return this.toArray().reduce((accumulator, element, index) => callback(accumulator, element, index), initialValue);\n  }\n\n\n  /**\n    * Finds the first element in the queue that satisfies the provided testing function.\n    * @param callback - The callback function to execute for each element.\n    * @returns The first element that satisfies the testing function, or undefined if no such element is found.\n    */\n  find(callback: (element: T, index: number) => boolean): T | undefined {\n    return this.toArray().find((element, index) => callback(element, index));\n  }\n\n\n  /**\n    * Checks if at least one element in the queue satisfies the provided testing function.\n    * @param callback - The callback function to execute for each element.\n    * @returns True if at least one element satisfies the testing function, false otherwise.\n    */\n  some(callback: (element: T, index: number) => boolean): boolean {\n    return this.toArray().some((element, index) => callback(element, index));\n  }\n\n\n  /**\n    * Checks if all elements in the queue satisfy the provided testing function.\n    * @param callback - The callback function to execute for each element.\n    * @returns True if all elements satisfy the testing function, false otherwise.\n    */\n  every(callback: (element: T, index: number) => boolean): boolean {\n    return this.toArray().every((element, index) => callback(element, index));\n  }\n\n}\n"],"names":["Queue","count","lowestCount","items","constructor","enqueue","element","add","dequeue","isEmpty","undefined","result","remove","peek","scry","size","length","clear","toArray","Object","values","toString","slice","join","asyncToStringGenerator","currentIndex","chunkSize","chunk","toStringAsync","forEach","callback","TypeError","queueObject","keys","queueLength","scopeArg","arguments","tempIterator","key","iteratorValue","call","Number","asyncForEachGenerator","asyncForEach","_","forEachReverse","reverse","index","map","filter","reduce","initialValue","accumulator","find","some","every"],"rangeMappings":"","mappings":"AAGA,OAAO,MAAMA,MACX,AAAQC,KAAc,AACtB,CAAQC,WAAoB,AAC5B,CAAQC,KAA4B,AAKpCC,cAAc,CACZ,IAAI,CAACH,KAAK,CAAG,CACb,CAAA,IAAI,CAACC,WAAW,CAAG,CACnB,CAAA,IAAI,CAACC,KAAK,CAAG,CAAC,CAChB,CAMAE,QAAQC,OAAU,CAAQ,CACxB,IAAI,CAACH,KAAK,CAAC,IAAI,CAACF,KAAK,CAAC,CAAGK,OACzB,CAAA,IAAI,CAACL,KAAK,EAAI,CAChB,CAMAM,IAAID,OAAU,CAAQ,CACpB,IAAI,CAACD,OAAO,CAACC,QACf,CAMAE,SAAyB,CACvB,GAAI,IAAI,CAACC,OAAO,GAAI,OAAOC,UAC3B,MAAMC,OAAS,IAAI,CAACR,KAAK,CAAC,IAAI,CAACD,WAAW,CAAC,AAC3C,QAAO,IAAI,CAACC,KAAK,CAAC,IAAI,CAACD,WAAW,CAAC,AACnC,CAAA,IAAI,CAACA,WAAW,EAAI,EACpB,OAAOS,MACT,CAMAC,QAAwB,CACtB,OAAO,IAAI,CAACJ,OAAO,EACrB,CAMAK,MAAsB,CACpB,GAAI,IAAI,CAACJ,OAAO,GAAI,OAAOC,UAC3B,OAAO,IAAI,CAACP,KAAK,CAAC,IAAI,CAACD,WAAW,CAAC,AACrC,CAMAY,MAAsB,CACpB,OAAO,IAAI,CAACD,IAAI,EAClB,CAMAJ,SAAmB,CACjB,OAAO,IAAI,CAACR,KAAK,CAAG,IAAI,CAACC,WAAW,GAAK,CAC3C,CAMAa,MAAe,CACb,OAAO,IAAI,CAACd,KAAK,CAAG,IAAI,CAACC,WAAW,AACtC,CAMAc,QAAiB,CACf,OAAO,IAAI,CAACD,IAAI,EAClB,CAKAE,OAAc,CACZ,IAAI,CAACd,KAAK,CAAG,CAAC,CACd,CAAA,IAAI,CAACF,KAAK,CAAG,CACb,CAAA,IAAI,CAACC,WAAW,CAAG,CACrB,CAMAgB,SAAe,CACb,OAAOC,OAAOC,MAAM,CAAC,IAAI,CAACjB,KAAK,CACjC,CAMAkB,UAAmB,CACjB,GAAI,IAAI,CAACZ,OAAO,GAAI,MAAO,GAC3B,MAAMW,OAASD,OAAOC,MAAM,CAAC,IAAI,CAACjB,KAAK,EAAEmB,KAAK,CAAC,IAAI,CAACpB,WAAW,CAAE,IAAI,CAACD,KAAK,EAC3E,OAAOmB,OAAOG,IAAI,CAAC,KACrB,CAMA,OAAOC,wBAAyB,CAC9B,GAAI,IAAI,CAACf,OAAO,GAAI,OACpB,MAAMW,OAASD,OAAOC,MAAM,CAAC,IAAI,CAACjB,KAAK,EACvC,IAAIsB,aAAe,IAAI,CAACvB,WAAW,CACnC,MAAMwB,UAAY,IAElB,MAAOD,aAAe,IAAI,CAACxB,KAAK,CAAE,CAChC,MAAM0B,MAAQP,OAAOE,KAAK,CAACG,aAAcA,aAAeC,WAAWH,IAAI,CAAC,KACxE,OAAMI,MACNF,cAAgBC,SAClB,CACF,CAOA,MAAME,eAAiC,CACrC,IAAIjB,OAAS,GACb,UAAW,MAAMgB,SAAS,IAAI,CAACH,sBAAsB,GAAI,CACvDb,QAAUgB,KACZ,CACA,OAAOhB,MACT,CAMAkB,QAAQC,QAAuF,CAAQ,CACrG,GAAI,IAAI,EAAI,KAAM,MAAM,IAAIC,UAAU,iCACtC,GAAI,OAAOD,WAAa,WAAY,MAAM,IAAIC,UAAU,CAAC,EAAED,SAAS,kBAAkB,CAAC,EAEvF,MAAME,YAAcb,OAAO,IAAI,EAC/B,MAAMc,KAAOd,OAAOc,IAAI,CAACD,YAAY7B,KAAK,EAC1C,MAAM+B,YAAsBD,KAAKjB,MAAM,CACvC,IAAImB,SACJ,GAAIC,UAAUpB,MAAM,CAAG,EAAGmB,SAAWC,SAAS,CAAC,EAAE,CAEjD,IAAK,IAAIC,aAAe,EAAGA,aAAeH,YAAaG,eAAgB,CACrE,MAAMC,IAAML,IAAI,CAACI,aAAa,CAC9B,MAAME,cAAgBP,YAAY7B,KAAK,CAACmC,IAAI,CAC5CR,SAASU,IAAI,CAACL,SAAUI,cAAeE,OAAOH,KAAMN,YAAY7B,KAAK,CACvE,CACF,CAOA,OAAOuC,sBAAsBZ,QAAgG,CAAE,CAC7H,GAAI,IAAI,EAAI,KAAM,MAAM,IAAIC,UAAU,iCACtC,GAAI,OAAOD,WAAa,WAAY,MAAM,IAAIC,UAAU,CAAC,EAAED,SAAS,kBAAkB,CAAC,EAEvF,MAAME,YAAcb,OAAO,IAAI,EAC/B,MAAMc,KAAOd,OAAOc,IAAI,CAACD,YAAY7B,KAAK,EAC1C,MAAM+B,YAAsBD,KAAKjB,MAAM,CAEvC,IAAK,IAAIqB,aAAe,EAAGA,aAAeH,YAAaG,eAAgB,CACrE,MAAMC,IAAML,IAAI,CAACI,aAAa,CAC9B,MAAME,cAAgBP,YAAY7B,KAAK,CAACmC,IAAI,AAC5C,OAAMR,SAASU,IAAI,CAAC9B,UAAW6B,cAAeE,OAAOH,KAAMN,YAAY7B,KAAK,CAC9E,CACF,CAEA,MAAMwC,aAAab,QAA4F,CAAiB,CAC9H,UAAW,MAAMc,KAAK,IAAI,CAACF,qBAAqB,CAACZ,UAAW,CAG5D,CACF,CAMAe,eAAef,QAA6C,CAAQ,CAClE,GAAI,IAAI,CAACrB,OAAO,GAAI,OACpB,MAAMwB,KAAOd,OAAOc,IAAI,CAAC,IAAI,CAAC9B,KAAK,EAAE2C,OAAO,GAC5C,IAAK,MAAMR,OAAOL,KAAM,CACtB,MAAMc,MAAQN,OAAOH,KAAO,IAAI,CAACpC,WAAW,CAC5C4B,SAAS,IAAI,CAAC3B,KAAK,CAACsC,OAAOH,KAAK,CAAES,MACpC,CACF,CAQAC,IAAIlB,QAA0C,CAAO,CACnD,OAAO,IAAI,CAACZ,OAAO,GAAG8B,GAAG,CAAC,CAAC1C,QAASyC,QAAUjB,SAASxB,QAASyC,OAClE,CAQAE,OAAOnB,QAAgD,CAAO,CAC5D,OAAO,IAAI,CAACZ,OAAO,GAAG+B,MAAM,CAAC,CAAC3C,QAASyC,QAAUjB,SAASxB,QAASyC,OACrE,CASAG,OAAOpB,QAA0D,CAAEqB,YAAe,CAAK,CACrF,OAAO,IAAI,CAACjC,OAAO,GAAGgC,MAAM,CAAC,CAACE,YAAa9C,QAASyC,QAAUjB,SAASsB,YAAa9C,QAASyC,OAAQI,aACvG,CAQAE,KAAKvB,QAAgD,CAAiB,CACpE,OAAO,IAAI,CAACZ,OAAO,GAAGmC,IAAI,CAAC,CAAC/C,QAASyC,QAAUjB,SAASxB,QAASyC,OACnE,CAQAO,KAAKxB,QAAgD,CAAW,CAC9D,OAAO,IAAI,CAACZ,OAAO,GAAGoC,IAAI,CAAC,CAAChD,QAASyC,QAAUjB,SAASxB,QAASyC,OACnE,CAQAQ,MAAMzB,QAAgD,CAAW,CAC/D,OAAO,IAAI,CAACZ,OAAO,GAAGqC,KAAK,CAAC,CAACjD,QAASyC,QAAUjB,SAASxB,QAASyC,OACpE,CAEF"}