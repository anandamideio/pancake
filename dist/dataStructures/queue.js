export class Queue{count;lowestCount;items;constructor(){this.count=0;this.lowestCount=0;this.items={}}enqueue(element){this.items[this.count]=element;this.count+=1}add(element){this.enqueue(element)}dequeue(){if(this.isEmpty())return undefined;const result=this.items[this.lowestCount];delete this.items[this.lowestCount];this.lowestCount+=1;return result}remove(){return this.dequeue()}peek(){if(this.isEmpty())return undefined;return this.items[this.lowestCount]}scry(){return this.peek()}isEmpty(){return this.count-this.lowestCount===0}size(){return this.count-this.lowestCount}length(){return this.size()}clear(){this.items={};this.count=0;this.lowestCount=0}toArray(){return Object.values(this.items)}toString(){if(this.isEmpty())return"";const values=Object.values(this.items).slice(this.lowestCount,this.count);return values.join(", ")}async *asyncToStringGenerator(){if(this.isEmpty())return;const values=Object.values(this.items);let currentIndex=this.lowestCount;const chunkSize=100;while(currentIndex<this.count){const chunk=values.slice(currentIndex,currentIndex+chunkSize).join(", ");yield chunk;currentIndex+=chunkSize}}async toStringAsync(){let result="";for await(const chunk of this.asyncToStringGenerator()){result+=chunk}return result}forEach(callback){if(this==null)throw new TypeError('"this" is null or not defined');if(typeof callback!=="function")throw new TypeError(`${callback} is not a function`);const queueObject=Object(this);const keys=Object.keys(queueObject.items);const queueLength=keys.length;let scopeArg;if(arguments.length>1)scopeArg=arguments[1];for(let tempIterator=0;tempIterator<queueLength;tempIterator++){const key=keys[tempIterator];const iteratorValue=queueObject.items[key];callback.call(scopeArg,iteratorValue,Number(key),queueObject.items)}}async *asyncForEachGenerator(callback){if(this==null)throw new TypeError('"this" is null or not defined');if(typeof callback!=="function")throw new TypeError(`${callback} is not a function`);const queueObject=Object(this);const keys=Object.keys(queueObject.items);const queueLength=keys.length;for(let tempIterator=0;tempIterator<queueLength;tempIterator++){const key=keys[tempIterator];const iteratorValue=queueObject.items[key];yield callback.call(undefined,iteratorValue,Number(key),queueObject.items)}}async asyncForEach(callback){for await(const _ of this.asyncForEachGenerator(callback)){}}forEachReverse(callback){if(this.isEmpty())return;const keys=Object.keys(this.items).reverse();for(const key of keys){const index=Number(key)-this.lowestCount;callback(this.items[Number(key)],index)}}map(callback){return this.toArray().map((element,index)=>callback(element,index))}filter(callback){return this.toArray().filter((element,index)=>callback(element,index))}reduce(callback,initialValue){return this.toArray().reduce((accumulator,element,index)=>callback(accumulator,element,index),initialValue)}find(callback){return this.toArray().find((element,index)=>callback(element,index))}some(callback){return this.toArray().some((element,index)=>callback(element,index))}every(callback){return this.toArray().every((element,index)=>callback(element,index))}}
//# sourceMappingURL=queue.js.map